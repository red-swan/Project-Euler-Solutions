open System

//  returns a binary string of a decimal integer
let binary (n:int) = Convert.ToString(n,2)

//  takes a tuple and returns the tuple as binary strings
let binarytuple (a:int,b:int,c:int) = 
    let max = [a;b;c] |> List.max |> binary
    let length = max.Length
    [a;b;c] |> List.map binary |> List.map (fun x-> x.PadLeft(length,'0'))

//  takes a binary string and returns a reversed 
let reversebinary (binarystring : string) = 
    binarystring.ToCharArray() |>Array.rev |> Array.map (fun x-> if x='1' then 1 else 0)


let nimsum input1 input2 input3 =
    let [a;b;c] = (input1,input2,input3)|> binarytuple |> List.map reversebinary
    let lastindex = a.Length - 1
    let answer = 
        Seq.unfold (fun n -> 
            if n > lastindex then None else 
            Some([a.[n];b.[n];c.[n]],n+1)) 0
    Seq.tryFind (fun x -> (List.sum x) |> (fun x-> x % 2) |> (fun x -> x =1)) answer
    |> (fun x-> match x with
                | Some x-> 1
                | None -> 0)

let candidates = 
    [1 .. 1000000]
    |> List.map (fun x-> (x,2*x,3*x))
    |> List.map (fun (a,b,c) -> nimsum a b c)
    |> List.sum

let answer = 
    Seq.unfold (fun n -> Some(nimsum n (2*n) (3*n),n+1)) 1
    |> Seq.take (int (2.0**30.0))
    |> Seq.filter (fun x-> x=0)
    |> Seq.length

let getcandidatetuple n = 
    binarytuple (n,2*n,3*n)
