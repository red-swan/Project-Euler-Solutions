(*Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal 
and D = |Pk − Pj| is minimised; what is the value of D?*)


// IDEAS //
// 1. scan the sequence by the window and increase the window until you get a hit
// 2. use floats




let pentagonalnumbers = Seq.unfold (fun x-> Some(((3.0*x-1.0)*x)/2.0,x+1.0)) 1.0 |> Seq.cache

let firstdifferences = Seq.unfold (fun x -> Some(3.0*x+1.0,x+1.0)) 1.0 |> Seq.cache

let ispentagonal x = if x<1.0 then false else ((sqrt (24.0* x  + 1.0) + 1.0) / 6.0) % 1.0 = 0.0

let ndifference index n = ((index + n) * (3.0*(index + n ) - 1.0) / 2.0) - (index * (3.0*index - 1.0) / 2.0)

let pentagonaltuples = Seq.unfold (fun (x,_) -> Some((x,x*(3.0*x-1.0)/2.0),(x+1.0,0.0))) (1.0,1.0) |> Seq.cache

let difference (index : int) (step : int) = //(x+n,((x + n) * (3.0*(x + n ) - 1.0) / 2.0) - (x * (3.0*x - 1.0) / 2.0))
    let x = float index
    let n = float step
    let here = (3.0*x*x-x)/2.0
    let there = (3.0*n*n+6.0*n*x-n+3.0*x*x-x)/2.0
    let difference = here-there
    ((x, here), (x+n,there), difference, ispentagonal difference)


let getv x = (3.0*x*x-x)/2.0
let getwindow x windowsize = [x-windowsize .. x+windowsize] |> List.map getv
let getwindow value windowsize = [value-windowsize .. value+windowsize] |> List.filter ispentagonal |> List.filter (fun x-> x<> value)
let hasproperty value windowsize = getwindow value windowsize |> List.filter (fun x->ispentagonal(value+x)) |> List.filter (fun x-> ispentagonal (x-value))
// not working
Seq.map2 hasproperty (pentagonalnumbers) (pentagonalnumbers) |> Seq.find (fun x-> Seq.isEmpty x |> not)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
let naturals = Seq.unfold (fun x-> Some(x,x+1.0)) 1.0 |> Seq.cache
let getallnumberswithin windowsize = naturals |> Seq.map getv |> Seq.takeWhile (fun x)
// need a sequence of cum sum of differences
let cumdiff = Seq.unfold (fun (x,diff) -> 
    let difference = 3.0*x+1.0
    Some(difference,(x+1.0,difference))) (1.0, 0.0) |> Seq.cache
// ??? How do we actually need the windows to work?
let cumdiff =  Seq.scan (fun acc elem -> acc + 3.0*elem+1.0) 0.0 naturals |> Seq.cache

// This should be the form for expanding the window and finding the correct matches
let rec findwindow number = 
    let algorithmoutput = algorithmforfindingwindows number
    if wehaveahit algorithm then algorithmoutput
    else findwindow number + 1
findwindow 1
    
//////////////////
let sumSeq sequence1 = Seq.scan (fun acc elem -> acc + elem) 0 sequence1
Seq.init 10 (fun index -> index * index)
|> sumSeq
|> Seq.toList
|> printfn "The sum of the elements is %d."
///////////////////////////////


let firstdifferences = pentagonalnumbers |> Seq.map ndifference
// This returns a tuple value with the index jumped to and the difference away from sequence indices
let difference (x,v) n = (x+n,((x + n) * (3*(x + n ) - 1) / 2) - (x * (3*x - 1) / 2))


let getv n = (3.0*n*n-n) / 2.0

let firstdifference i = ndifference i 1.0 |> ispentagonal

Seq.find firstdifference pentagonalnumbers
